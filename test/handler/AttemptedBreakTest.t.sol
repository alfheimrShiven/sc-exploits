// SPDX-License-Identifier: MIT

pragma solidity 0.8.20;

import {HandlerStatefulFuzzCatches} from "../../src/invariant-break/HandlerStatefulFuzzCatches.sol";
import {Test} from "forge-std/Test.sol";
import {StdInvariant} from "forge-std/StdInvariant.sol";
import {MockUSDC} from "../mocks/MockUSDC.sol";
import {YieldERC20} from "../mocks/YieldERC20.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract AttemptedBreakTest is StdInvariant, Test {
    address user = makeAddr("user");
    MockUSDC mockUSDC;
    YieldERC20 yieldERC20;
    IERC20[] supportedTokens;
    HandlerStatefulFuzzCatches public hsfc;
    uint256 public STARTING_AMOUNT;

    function setUp() external {
        vm.startPrank(user);
        yieldERC20 = new YieldERC20();
        mockUSDC = new MockUSDC();
        STARTING_AMOUNT = yieldERC20.INITIAL_SUPPLY();
        mockUSDC.mint(user, STARTING_AMOUNT);
        vm.stopPrank();

        // supportedTokens = [mockUSDC, yieldERC20];
        supportedTokens.push(mockUSDC);
        supportedTokens.push(yieldERC20);
        hsfc = new HandlerStatefulFuzzCatches(supportedTokens);
        targetContract(address(hsfc));
    }

    function testStartingAmount() external {
        assertEq(STARTING_AMOUNT, mockUSDC.balanceOf(user));
        assertEq(STARTING_AMOUNT, yieldERC20.balanceOf(user));
    }

    function statefulFuzz_testInvariantBreaks() external {
        // assertEq(hsfc.tokenBalances[user][mockUSDC], 0);
        // assertEq(hsfc.tokenBalances[user][yieldERC20], 0);

        vm.startPrank(user);
        hsfc.withdrawToken(mockUSDC);
        hsfc.withdrawToken(yieldERC20);
        vm.stopPrank();

        assertEq(mockUSDC.balanceOf(user), STARTING_AMOUNT);
        assertEq(yieldERC20.balanceOf(user), STARTING_AMOUNT);

        assertEq(mockUSDC.balanceOf(address(hsfc)), 0);
        assertEq(yieldERC20.balanceOf(address(hsfc)), 0);
    }
}
